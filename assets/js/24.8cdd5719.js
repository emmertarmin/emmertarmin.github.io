(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{540:function(e,t,a){"use strict";a.r(t);var o=a(41),n=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("It's been a few days since I haven't been able to locate the bottleneck in an I2C bus. I'm polling data from a vibration sensor, but can't seem to get the data rate as high as is being advertised. Actually, it's hard to tell just from code and debug info, on what rate I'm getting sensor data at all. And it's hard to \"imagine\" what really plays down in a 3200kHz communication protocol. Or to determine whether it's working at 3200Hz at all.")]),e._v(" "),a("p",[e._v("Cue the term \"logic analyzer\". I can't believe I haven't heard about that before. To be honest, I think I was generally too slow to catch up on the existence of any kind kind of hardware debug accessory. I knew I needed to get one!")]),e._v(" "),a("p",[e._v("There's a great brand that I've heard many people recommend, but there's also cheap Chinese clones for a tenth of the price, that do just as much, and that nobody recommends. Not being able to resist a €10.99 purchase, I ordered one on eBay. Before even trying any free "),a("a",{attrs:{href:"https://sigrok.org/"}},[e._v("open source")]),e._v(" software with it, I just tried the one from Saleae, which is also free, and it worked with the noname clone flawlessly.")]),e._v(" "),a("p",[e._v("I don't know what I was expecting, but the usage of it is as trivial as it gets. Connect the channels to the logic level lines that you intend to sniff, connect ground too, assign the SDA and SCL to the matching channels inside the software, et violá. High and Low states get polled at 20MHz for a full second, and are then presented for analysis. The Saleae software decodes bytes even on hover, and translates them to hexadecimal, decimal, or ascii characters. The whole string of communication can then be exported to csv files too, if needed.")]),e._v(" "),a("p",[e._v("Even without decoding, I instantly recognized some schemes. After requesting to read a register (3 separate bytes worth of blocks in the I2C clock channel) there would be an unnecessarily long looking string of bytes. Turns out I've been requesting a good 100-150 bytes of data through I2C instead of only asking for the 6 important registers of the sensor that I'm interested in. Prior to using a logic analyzer, I didn't imagine that such sloppiness could clog the bus.")]),e._v(" "),a("p",[e._v("Thinking back now, I feel so stupid having used selfie cameras to check infra leds in the past. Often I've \"debugged\" by asking the MCU to toggle a led during a process, just so I can confirm it's doing stuff. Toggling leds however takes time, and is hard to see, when it's supposed to happen every millisecond. Now I can debug data lines without changing the code, like a pro.")]),e._v(" "),a("p",[e._v('Lately I have been "feeling an increasing need" (=searching for an excuse) to buy an oscilloscope too, but this supercheap logic analyzer has got 99% of my needs covered for the foreseeable future (probably 100%, actually).')])])}),[],!1,null,null,null);t.default=n.exports}}]);