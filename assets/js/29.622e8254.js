(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{547:function(e,n,i){"use strict";i.r(n);var t=i(41),a=Object(t.a)({},(function(){var e=this,n=e.$createElement,i=e._self._c||n;return i("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[i("p"),i("div",{staticClass:"table-of-contents"},[i("ul",[i("li",[i("a",{attrs:{href:"#einfuhrung"}},[e._v("Einführung")])]),i("li",[i("a",{attrs:{href:"#commit"}},[e._v("Commit")])]),i("li",[i("a",{attrs:{href:"#branching"}},[e._v("Branching")])]),i("li",[i("a",{attrs:{href:"#merge-und-rebase"}},[e._v("Merge und Rebase")])]),i("li",[i("a",{attrs:{href:"#remote"}},[e._v("Remote")])]),i("li",[i("a",{attrs:{href:"#nutzlich"}},[e._v("Nützlich")])])])]),i("p"),e._v(" "),i("h3",{attrs:{id:"einfuhrung"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#einfuhrung"}},[e._v("#")]),e._v(" Einführung")]),e._v(" "),i("p",[e._v("Git ist ein Version Tracker.\nMeistens clonen wir ein bestehendes Repository mit "),i("code",[e._v("git clone <url>")])]),e._v(" "),i("p",[e._v("Lokal können wir einen ordner mit\n"),i("code",[e._v("git init")]),e._v(" anfangen zu verfolgen.\nbeides kommt mit einem versteckten .git Ordner, den wir aber nie anfassen müssen.\nName und Email werden beim commit verlangt, damit man weiß wen man blamieren muss.")]),e._v(" "),i("h3",{attrs:{id:"commit"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#commit"}},[e._v("#")]),e._v(" Commit")]),e._v(" "),i("p",[e._v("Es gibt 3 wichtige Orte im Konzept:")]),e._v(" "),i("ul",[i("li",[e._v("Working Directory (WD)")]),e._v(" "),i("li",[e._v("Staging Area (SA)")]),e._v(" "),i("li",[e._v("Repository (REPO)")])]),e._v(" "),i("p",[e._v("WD ist der Ordner in dem ich arbeite.\nManuell würde man Backups folgender weise machen: Ordner zippen, und irgendwo verstauchen. Ich werde diese Analogie benutzen, aber im Hintegrund ist git viel schlauer. Nach dem ersten commit merkt er sich lediglich Deltas (zeilenweise änderungen), deshalb brauchen alle späteren backups kaum Speicherplatz über der WD.")]),e._v(" "),i("p",[e._v("Git sieht welche files ich geändert habe, und listet sie mir durch "),i("code",[e._v("git status")]),e._v(". Dies differenziert auch zwischen staged und unstaged files, zeigt sie in unterschiedlichen farben.\nDie angezeigten änderungen werden relativ zum letzten commit gezeigt.")]),e._v(" "),i("p",[e._v("Wenn ich 3 files im Ordner habe, aber mit dem dritten noch nicht fertig bin, trotzdem bereits einen backup erstellen möchte, schiebe ich nur die ersten zwei files in die SA mit "),i("code",[e._v("git add <filename>")]),e._v(".\nWenn beide Files im SA sind, kann ich committen: "),i("code",[e._v('git commit -m "message"')]),e._v(".\nNach dem Commit macht git einen zip wo die zwei Files neu sind, und das dritte noch vom älteren backup stammt.\nManchmal merkt man dass nach einem commit noch rechtschreibfehler drin sind, dann kann man die kleinere änderungen durch "),i("code",[e._v("git commit --amend")]),e._v(" dem letzten commit dranhängen, sodass kein neues commit mit neuer message erstellt wird.")]),e._v(" "),i("p",[e._v('Häufige Probleme:\n"Ich möchte ein file nicht tracken, hab es im gitignore drin, es wird aber trotzdem verfolgt. Ich habe die .gitignore Datei auch committet"\nWenn ein file irgendwann schon mal verfolgt wurde, und man es nachträglich ins gitignore schreibt, wird es nicht ignoriert. Man muss die Verfolgung der Datei stoppen mit '),i("code",[e._v("git rm <file> --cached")]),e._v(". Die Datei selbst wird im WD nicht gelöscht, aber sie wird vom REPO entfernt, und von da an nichtmehr verfolgt.")]),e._v(" "),i("p",[e._v('"Okay, aber ich will die Datei beibehalten, bloß meine lokale änderungen nicht mitnehmen"\n'),i("code",[e._v("git update-indec --assume-unchanged <file>")])]),e._v(" "),i("p",[e._v('"Ich habe etwas committet, habe aber etwas vermasselt und möchte den commit löschen"\nCommits löschen wir nie. Wenn möglich, reparieren wir den Fehler und committen erneut.\nWenn es um zu viele falsche Files geht, dann können wir die letzten commits mit '),i("code",[e._v("git log")]),e._v(" ansehen, und mit "),i("code",[e._v("git revert <commit>")]),e._v(" zu einem früheren commit zurückkehren. Hierbei wird ein neuer commit erstellt, der eine neue message erwartet, dies kann man mit "),i("code",[e._v("git revert --no-edit <commit>")]),e._v(" umgehen.\nWenn ich noch vor dem commit etwas ändern möchte, dann "),i("code",[e._v("git revert --no-commit <commit>")]),e._v(", änderungen anlegen, und danach "),i("code",[e._v("git commit...")])]),e._v(" "),i("h3",{attrs:{id:"branching"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#branching"}},[e._v("#")]),e._v(" Branching")]),e._v(" "),i("p",[e._v("Manchmal möchte ich meine änderungen in einen eigenen backup Ordner schieben, ich will aber nicht dass andere darauf ungewollt zugreifen. Da mach ich halt einen Branch mit "),i("code",[e._v("git checkout -b <branch_name>")]),e._v(". Um zu checken in welchem branch ich bin, einfach "),i("code",[e._v("git branch")]),e._v(". Als Ausgang für einen Branch kann jeder commit dienen. Um auf ein bereits existierendes Branch zu wechseln einfach "),i("code",[e._v("git checkout <branch_name>")]),e._v(". Dabei kommt man auf das absolut neueste commit von dem angegebenen Branch.")]),e._v(" "),i("p",[e._v("Beispiel: Ich hab meinen Armin Branch, und Angelina Jolie hat ihr Angelina Branch. Sie arbeitet an einer feature, und speichert alles schön, macht regelmäßig commits, und ich arbeite an miener, und mache regelmäßig commits. Nun brauch ich ihre Hilfe. Sie macht einen checkout auf meinen Branch, und plötzlich, wie Magie, ändern sich alle Files in ihrem WD auf die die in meinem letzten commit drin waren. Sie macht ihr ding, commitet (und pusht), und checkt wieder ihren  eigenen branch aus um da weiter zu machen. Ich mach einen git pull (dazu später), et voilá, ich habe alle ihre änderungen nun in meiner WD.")]),e._v(" "),i("p",[e._v("Hier kommt HEAD ins gespräch: HEAD ist immer das allerneueste commit in dem jeweiligen Branch wo ich gerade bin. Dies ist auch unter "),i("code",[e._v(".git/HEAD")]),e._v(' in einer Variable gespeichert.\nMan kann diese Variable auf was anderes umstellen, dann spricht man von einem DETACHED HEAD. Das macht man indem man "checkout" nicht auf einen Branch, sondern auf ein Commit durchführt.')]),e._v(" "),i("p",[e._v("Im Beispiel von vorhin: Wenn Angelina nicht meinen Branch asucheckt, sondern meinen letzten commit, dann kann sie mir nicht weiterhelfen. Sie ist dann in einem Detached Head. Sobald sie einen Branch auscheckt, sodass sie einen aktiven Branch hat, wechseln sich all ihre files in der WD auf die von dem Branch, und ihre änderungen gehen verloren.")]),e._v(" "),i("p",[e._v("Kurz und gut: ein detached head heißt es gibt gerade keinen aktiven Branch, die WD representiert nicht den neuesten Stand von einem Branch. Einfach einen branch auschecken, und erst dann anfangen Dinge zu ändern.")]),e._v(" "),i("p",[e._v("Man kann branches auch aufeinander resetten mit "),i("code",[e._v("git reset --hard <branch>")]),e._v(". Bitte nur mit Obacht, es können wesentliche Unterschiede im Code verloren gehen.")]),e._v(" "),i("h3",{attrs:{id:"merge-und-rebase"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#merge-und-rebase"}},[e._v("#")]),e._v(" Merge und Rebase")]),e._v(" "),i("p",[e._v("Sagen wir mal ich hab meinen Feature Branch, da Dinge geändert, in der zwischenzweit ist der Master branch auch vorangekommen, und ich möchte nun meine Feature in den Master einbauen.")]),e._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[e._v("1 -> 2 -> 3 -> 5  Master \n     |\n     ˇ--\x3e 4 -> 6  Feature\n")])])]),i("p",[e._v("Es gibt zwei Möglichkeiten:")]),e._v(" "),i("ul",[i("li",[e._v("Den Master branch auschecken und den Feature Branch reinmergen.")]),e._v(" "),i("li",[e._v('Den Feature branch "rebasen", und zwar auf das neueste commit vom Master Branch.')])]),e._v(" "),i("p",[e._v('Beim merge schaut sich git an ob es konflikte gibt (Wenn die selbe Zeile in beiden Branches unterschiedlich geändert wurde). Merge Conflicts müssen gelöst werden, dazu gibt es tolle tools, wie "git tree compare" in VSCode. Wenn es keine conflicts (mehr) gibt, wird ein neues commit erzeugt, das von sowohl dem Master als auch dem Feature Branch abstammt. Im Graph waren die Branches abgezweigt, und nun sind sie zusammengewachsen und eins geworden.')]),e._v(" "),i("p",[i("code",[e._v("git checkout master")])]),e._v(" "),i("p",[i("code",[e._v("git merge <branch>")])]),e._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[e._v("1 -> 2 -> 3 -> 5 ------\x3e 7  Master \n     |              ^  \n     ˇ--\x3e 4 -> 6 ---|       Feature\n")])])]),i("p",[e._v("Beim rebase werden die Zweige straffgezogen, sodass es am ende nur noch eins gibt. Wir sagen dem Master brach, dass er und seine neue commits sich nicht auf das alte abgezweigte commit basieren soll, sondern dass sich diese commits lieber auf die Spitze von meinem Feature Branch draufbauen sollen.\nKein example, da ausdürcklich verboten.")]),e._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[e._v("1 -> 2 -> 4 -> 6 -> 3 -> 5 -> 7  Master\n")])])]),i("p",[e._v("Hier sieht man was ein Rebase macht, aber rebase ist ABSOLUT VERBOTEN. Den master, den wir mit anderen teilen möchten, den darf man NIE mit rebase anrühren. Alles was nicht ausschließlich bei uns lokal bleibt, darf man NIE mit rebase anrühren. Die Probleme die man für andere erzeugt wenn sie gerade am master arbeiten, welches wir rebasen, und sie versuchen zu commiten und zu pushen.... sind legendär.")]),e._v(" "),i("p",[e._v("Okay, wozu dient dann ein rebase?")]),e._v(" "),i("p",[e._v("Es kann sein, dass meine Feature von einem commit von gestern abzweigt, dass es heute aber im master eine Funktion gibt die ich auch bräuchte, aber keine Lust habe manuell  alles reinzukopieren. Ein anderer Fall ist es dass ich meine Feature gegen einen neuren Stand des masters testen möchte.\nIn diesem Fall kann ich meine Feature auf den heutigen commit rebasen, sodass diese Funktion bei mir dann bereits drin ist. und meine änderungen auch alle bleiben. Das geht leider nicht immer, oft muss man einige conflicts manuell lösen.")]),e._v(" "),i("h3",{attrs:{id:"remote"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#remote"}},[e._v("#")]),e._v(" Remote")]),e._v(" "),i("p",[e._v("Hier kommt github ins spiel. Github dient dazu dass unsere lokale commits aufs internet kommen, sodass andere sie auschecken können. Synkronisation ist in diesen Fall nicht automatisch, sondern man muss sie manuell mit PUSH hochladen, und mit FETCH herunterladen. Beim PULL wird im Hintergrund eigentlich ein FETCH und ein MERGE durchgeführt. Der Grund dafür ist dass ich vielleicht auf dem gleichen Branch was geändert habe wie jemand anderes. Mein branch ist lokal abgezweigt von dem stand des remote branch, deswegen muss natürlich ein merge passieren, um alles auszubügeln.")]),e._v(" "),i("p",[e._v("Um dem lokalen git repo zu erklären zu welchem remote github remot er gehört, muss man "),i("code",[e._v("git remote add origin <remote_url>")]),e._v(' ausführen.\nDie remote repository hört auf den namen "origin", dehalb beim push: '),i("code",[e._v("git push -u origin master")]),e._v(", bzw. "),i("code",[e._v("git push -u origin <branch>")])]),e._v(" "),i("p",[e._v("damit man sich nicht jedesmal einzeln einloggen muss, kann man "),i("code",[e._v("git config --global credential.helper store")]),e._v(" durchführen, sodass git sich während dem nächsten login die Zugangsdaten speichert.")]),e._v(" "),i("h3",{attrs:{id:"nutzlich"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#nutzlich"}},[e._v("#")]),e._v(" Nützlich")]),e._v(" "),i("p",[e._v("Stash ist nützlich wenn man noch nicht commiten möchte, aber auf ein anderes branch wechseln will. In dem fall kann man die WD mit "),i("code",[e._v("git stash")]),e._v(" einfach lokal in eine sichere Schublade verstecken, und demnächst mit "),i("code",[e._v("git stash pop")]),e._v(" wieder hervorbringen. Git wird nicht zulassen dass ich einen anderen branch auschecke solange es ungespeicherte änderungen in meiner WD gibt.")]),e._v(" "),i("p",[e._v("Wenn git installiert ist, sollte man als erstes name und email angeben:")]),e._v(" "),i("p",[i("code",[e._v('git config --global user.name "name"')])]),e._v(" "),i("p",[i("code",[e._v('git config --global user.email "email"')])]),e._v(" "),i("p",[e._v("configs auszulisten: "),i("code",[e._v("git config --list")])]),e._v(" "),i("p",[e._v("help: "),i("code",[e._v("git help xyz")]),e._v(" z.B. "),i("code",[e._v("git help commit")])]),e._v(" "),i("p",[e._v("Um eine Repository zu erzeugen, damit git den Ordner anfängt zu verfolgen, geht man in den Ordner "),i("code",[e._v("cd Ordner")]),e._v(" und initialisiert mit "),i("code",[e._v("git init")]),e._v("\nUm eine Basis zu haben, macht man den ersten commit, und dafür sagt man welche files da drin sein sollen (welche in die staging area (SA) sollen). Wenn alles, dann "),i("code",[e._v("git add .")]),e._v(", danach "),i("code",[e._v('git commit -m "message"')]),e._v(".\nWenn sowieso alle Files mitgehen sollen, kann man die zwei steps zusammen ausführen mit "),i("code",[e._v('git commit -am "message"')]),e._v(".")]),e._v(" "),i("p",[e._v("Die commits auslisten: "),i("code",[e._v("git log")]),e._v("\nCommits auf author filtern: "),i("code",[e._v('git log --author="name"')]),e._v("\nDen graph aunzusehen: "),i("code",[e._v("git log --graph")])]),e._v(" "),i("p",[i("code",[e._v("git status")]),e._v(" zeigt welche files in der WD relativ zum letzten commit geändert wurden, und welche bereits in der SA sind.")]),e._v(" "),i("p",[i("code",[e._v("git diff <file>")]),e._v(" zeigt die zeilenweise unterschiede innerhalb des files.")]),e._v(" "),i("p",[i("code",[e._v("git rm <file>")]),e._v(" löscht die Datei, und stellt die Verwerfung auch in die SA, sodass die Datei auch im nächsten commit fehlen wird.")]),e._v(" "),i("p",[i("code",[e._v("git mv <file> <file>")]),e._v(" dies ist die UNIX weise der Umbenennung. In Windows wird eine Umbenennung einer Datei als löschen der alten und erzeugung der neuen behandelt.")]),e._v(" "),i("p",[i("code",[e._v("git checkout -- <file>")]),e._v(" ladet die File von der repo herunter und wechselt sie in der WD aus.")]),e._v(" "),i("p",[i("code",[e._v("git checkout <commit_id> -- <file>")]),e._v(" bringt die Datei von der angegebenen commit in die WD.")]),e._v(" "),i("p",[i("code",[e._v("git reset HEAD <file>")]),e._v(" bringt eine Datei zurück von der SA in die WD. Das gegenteil von "),i("code",[e._v("git add <file>")])])])}),[],!1,null,null,null);n.default=a.exports}}]);